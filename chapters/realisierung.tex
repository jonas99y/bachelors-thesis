\chapter{Realisierung}
% Dies ist das Hauptkapitel Ihrer Arbeit! Hier wird die Umsetzung der eigenen Ideen und Konzepte
% (Kapitel 3) anhand der gewählten Methoden (Kapitel 4) beschrieben, inkl. der dabei aufgetretenen
% Schwierigkeiten und Einschränkungen.
Die Realisierung lässt sich in drei Phasen unterteilen.

In der ersten Phase werden grundlegende Entscheidungen getroffen und die Basis der Arbeit implementiert.
Am Ende der ersten Phase existiert ein Prototyp,
welcher bei allen Komponenten des System über die minimalen Funktionen verfügt. (TODO verweis )

Wie im Kapitel Vorgehen beschrieben (TODO), folgen darauf zwei weitere Phasen,
in welche neue Anforderungen des Auftraggebers umgesetzt werden.

\section{Grundlegende Designentscheidungen}

Der folgende Abschnitt gibt einen Überblick der gewählten Technologien und
der grundlegenden Designentscheidungen und wieso diese so umgesetzt wurden.

\subsection{Auswahl des Technologiestacks}

Bei er Auswahl des Technologiestacks wurde auf verschiedene Aspekte geachtet.
Zum einen sollte das Frontend unabhängig vom Backend entwickelt werden können.
Aus diesem Grund wurde für die Kommunikation, wie in Kapitel \ref{konzepte:api-kommunikation}
bereits beschrieben, eine \ac{REST} \ac{API} verwendet.
Auf die genaue Definition der \ac{API} wird in den nächsten Abschnitten noch genauer eingegangen.

Für die Implementation des Backends gibt es unzählige Technologien die man für eine \ac{CRUD}
Applikation verwenden kann (Siehe Kapitel \ref{state:backend}). Für dieses Projekt sollte
eine \ac{REST} \ac{API} implementiert werden können. Und die Datenbank soll über ein \ac{ORM}
abstrahiert werden können. Dies hat den Vorteil, dass die eigentliche Datenbanktechnologie
keine grosse Rolle spielt. Das \ac{ORM} abstrahiert die Tabellenstruktur mittels
Objekten im Sourcecode. Als Backend kann beispielsweise zum Testen und Entwickeln
eine Sqlite\footnote{https://www.sqlite.org/index.html} Datenbank verwendet werden.
Der gleiche Sourcecode kann danach in der Produktion auf eine PostgreSQL\footnote{https://www.postgresql.org/}
Datenbank zugreifen um besser zu skallieren.
Natürlich soll auch ein \ac{MQTT} Framework in der gewählten Technologie zur verfügung stehen
damit die Messdaten der Stromzähler empfangen und in die Datenbank abgespeichert werden können.

Python bietet für jedes dieser Anforderungen gleich mehrere Frameworks an. Mit Python können sehr
schnell Prototypen erstellt werden. Es eignet sich aber auch für grosse Produktivsoftware.
Einige der wohl Bekanntesten Programme wie YouTube, Instagram, Spotify oder Reddit sind
in Python geschrieben. \cite{popular_python_sw}

Bei der Implementation des Frontends wurde wie in Kapitel \ref{state:frontend} beschrieben
anhand der State of Js Umfragen React\footnote{https://reactjs.org/} verwendet.
Um nicht das ganze Benutzerinterface selber gestalten zu müssen, wurde eine Material Design\footnote{https://material.io/design}
Library verwendet.

Um die Applikation für die Entwicklung lokal aufzusetzen, zu testen oder zu Deployen wurde dazu
Podman verwendet (Siehe Kapitel \ref{state:deployment}).

\subsection{Datenbankschema}

Gleich zu beginn des Projektes wurde das Datenbankschema erstellt.
Dies gibt eine gute Übersicht ob die für das Projekt benötigten Daten
abgespeicher werden können. In diesem Fall sind das die Messwerte der Stromzähler
und die Labels des Benutzers.

Die Datenbank wurde so einfach wie möglich gehalten um alle vorgegebenen
Anforderungen zu erfüllen.

\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{gfx/smic-db}
    \caption{
        ER Diagramm der Datenbank
    }
    \label{fig:smic-db}
\end{figure}

Wie in Abbildung \ref{fig:smic-db} dargestellt, können in der Datenbank
die Verschiedenen Stromzähler mit ihrer Seriennumer abgespeichert werden.
Beispielsweise wird pro Haushalt ein Stromzähler mit einer bestimmten
Seriennummer abgespeichert, sobald dieser zum ersten mal Daten sendet.
Ein solcher Stromzähler sendet danach einzelne Messdaten zu bestimmten
Zeitpunkten. Die Messdaten beinhalten neben der Messzeit die drei Phasen
und wie viel Leistung gebraucht wurde.

Damit danach abgespeichert werden kann zu welcher Zeit beispielsweise ein
Toaster gelaufen ist, werden Labels erstellt. Ein solches Label hat eine
Bezeichnung und kann verschiedene Annotationen beinhalten.
Eine Annotation ist immer von einem bestimmten Stromzähler und kann implizit mehrere
Messdaten beinhalten. Dies wird über eine Start- und Endzeit abgespeichert.
Durch diese Struktur können danach einfach Auswertungen der Labels über mehrere
Stromzähler und Messpunkte gemacht werden.

\subsection{Architekturentscheidung}
\label{architekturentscheidung}

In dieser Arbeit wird keine Microservice Architektur im klassischen Sinne verwendet. (Siehe Kapitel \ref{konzepte:microservices})
Die einzelnen Komponenten werden zwar in separaten Container deployt (Abbildung: \ref{fig:smic-arch})
besitzen jedoch keine eigene Datenbank.
Das hat den Vorteil, dass weniger Overhead implementiert werden muss (mittels Message Queue)
und das Datenbankschema kann zentral in der Datastore Library einmal definiert
und dann in den verschiedenen Komponenten wiederverwendet werden.


\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{gfx/smic-arch}
    \caption{
        Schematische Darstellung der in diesem Projekt verwendeten Architektur
    }
    \label{fig:smic-arch}
\end{figure}

Die Abbildung \ref{fig:smic-arch} zeigt die in diesem Projekt verwendete
Architektur auf. Hier noch einige Informationen zu den einzelnen Komponenten:


\begin{itemize}
    \item \texttt{nginx}:
        Alle Anfragen des Endbenutzers werden über einen Nginx Server
        entgegengenommen. Dieser liefert dann dem Benutzer die React WebApp
        oder leitet Anfragen an die \ac{API} weiter.

    \item \texttt{api}:
        Die \ac{API} verarbeitet Datenanfragen der React WebApp. Sie gibt
        beispielsweise die Stromzählerdaten eines Tages zurück.

    \item \texttt{datastore}:
        Der datastore ist eine Python library, die das Datenbankschema mittels \ac{ORM} festlegt.
        Sowohl die \ac{API} als auch der dataingress greifen auf die Datenbank zu
        und verwenden somit die datastore library.

    \item \texttt{dataingress}:
        Der dataingress arbeitet die von den \ac{IoT} Geräten gesendeten
        Stromzählerdaten ab und speichert diese in die Datenbank.

    \item \texttt{mosquitto}:
        Mosquitto ist der in dieser Arbeit verwendete \ac{MQTT} Broker.
\end{itemize}

Ein weiterer grund für die Entscheidung einer geteilten Datenbank ist,
dass der \texttt{dataingress} keine Daten liest, sondern diese nur von
der \ac{MQTT} Queue abarbeitet und in die Datenbank schreibt.

Auf die einzelnen Komponenten wird später in der Realisierungsphase noch genauer
eingegangen.

\subsection{Continous Integration, Contionous Delivery}

Um das Projekt automatisch Testen zu können und eine Reproduzierbare Umgebung zu bauen,
wurde bereits zu Beginn eine \ac{CI/CD} Pipeline mit GitHub Actions\footnote{https://github.com/features/actions}
aufgebaut.
Die Entwickler sollen sich nicht nur um die Entwicklung, sondern auch das automatische Bauen und Deployen der
Software kümmern. Dieser DevOps Gedanke hat den Vorteil, dass
theoretisch jedes kleine Feature und jeder Bugfix direkt automatisiert getestet
wird und danach (wenn die Tests erfolgreich waren) auf das Produktivsystem
Deployt werden kann. \cite{what_is_devops}
zudem ist für jeden Entwickler das Bauen und Ausführen des Projektes gleich und
reproduzierbar. Dies erspart das Suchen von unnötigen Fehlern die auf unterschiedlich
konfigurierten Entwicklungsmaschinen auftreten können.

\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{gfx/ci-env}
    \caption{
        Visualisierung der GitHub Actions Pipeline mit zwei aufeinanderfolgenden Stages.
        Zuerst werden die einzelnen Komponenten (Siehe \ref{fig:smic-arch}) gebaut und
        anschliessend getestet.
    }
    \label{fig:ci-env}
\end{figure}

Dank dieser \ac{CI/CD} Umgebung und der Verwendung von Podman, kann die gesamte Applikation
(Wie im Kapitel \ref{architekturentscheidung} beschrieben) mit einem
Befehl gebaut und gestartet werden.

\section{Verarbeitung und Visualisierung von Stromzählerdaten}

In einer ersten Phase werden laut der Aufgabenstellung \ref{aufgabenstellung} Stromzähler
Messdaten per \ac{MQTT} empfangen und in eine Datenbank gespeichert.
Diese gespeicherten Daten werden dann in einer WebApp visualisiert und dem Benutzer
angezeigt.

\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{gfx/usecase1}
    \caption{
        UseCase Diagramm der Verarbeitung und Visualisierung von Stromzählerdaten.
    }
    \label{fig:usecase1}
\end{figure}

\subsection{Frontend und Backend Abstraktion}

Damit die Arbeit von Frontend und Backend aufgeteilt werden kann, wurde zuerst
die \ac{API} Schnittstelle definiert. Für die Implementierung im Backend
stand die Entscheidung zwischen Flask\footnote{https://flask.palletsprojects.com/en/2.0.x/}
und FastAPI\footnote{https://fastapi.tiangolo.com/}.
Flask ist ein simples Web Framework mit dem \ac{API}s aber auch Server Side Rendering \cite{flask_server_side}
gemacht werden kann. FastAPI ist ein typisiertes Framework das darauf spezialisiert ist
\ac{REST} \ac{API}s zu implementieren. FastAPI ist ähnlich aufgebaut wie Flask aber auf den
\ac{API} Bereich spezialisiert. Die Dokumentation wird auch automatisch generiert.
FastAPI eignet sich perfekt um die \ac{API} zwischen Frontend und Backend zu implementieren.

\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{gfx/api-visualization}
    \caption{
        \ac{API} Definition für die Visualisierung von Stromzählerdaten
    }
    \label{fig:api-visualization}
\end{figure}

Wie in Abbildung \ref{fig:api-visualization} dargestellt, besteht die \ac{API} der Stromzähler
und Messdaten ausschliesslich aus Abfragen. Die zu speichernden Daten kommen dann (wie im nächsten
Abschnitt erklärt) aus den \ac{MQTT} Daten der Stromzähler selbst.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{gfx/sim-arch-api}
    \caption{
        Architektur der \ac{API} zwischen Frontend und Backend
    }
    \label{fig:arch-visualization-front-back}
\end{figure}

Sobald die WebApp von einem Benutzer aufgerufen wird, lifert der Nginx Server
die WebApp per \ac{HTTP} request aus. (Abbildung \ref{fig:arch-visualization-front-back})
Wenn der Benutzer (in diesem Fall über das React Web Frontend) danach die Messdaten seines
Stromzählers abfragen will, wird ebenfalls eine Asynchrone \ac{HTTP} Anfrage an die Backend \ac{API} gemacht.
Die Abfrage landet dann beim Nginx und wird an das Python FastAPI Backend weitergeleitet.
Dieses Python Backend führt danach eine SQL Abfrage via \ac{ORM} auf der Datenbank aus.
Um die Daten im Web Frontend anzeigen zu können, werden sie noch \ac{JSON} serialisiert
und zurück an die WebApp gesendet.

Die datastore Python Library stellt der \ac{API} das Datenbankschema zur Verfügung,
damit das \ac{ORM} die Abfragen an die Datenbank machen kann.
Als \ac{ORM} Framework wird sqlmodel\footnote{https://github.com/tiangolo/sqlmodel} verwendet.
Sqlmodel wird vom gleichen Entwickler wie FastAPI maintaint und bietet eine gute Integration.

Da nun das Datenmodell (in der datastore Library) und die \ac{API} definiert wurden,
kann das Web Frontend unabhängig vom Verarbeiten der \ac{MQTT} Daten gemacht werden.

\subsection{Implementation der Backend \ac{API}}

Wie alle Python Komponenten dieses Projektes wird auch das Backend \ac{API}
als Python Poetry\footnote{https://python-poetry.org/} Projekt implementiert.
Poetry verbessert das Paketmanagement von Python erheblich gegenüber Setuptools
und pip. \cite{python_poetry}
Dadurch ist es auch einfacher die Applikation als Container zu bauen und
damit einen reproduzierbaren Build zu garantieren.

Die Datenbankanbindung kann per Datenbank \ac{URI} dem sqlmodel Framework
mitgegeben um zu bestimmen auf welche Datenbank zugegriffen werden soll.

\subsection{Implementation der Datenvisualisierung}
Vorgabe für die Datenvisualisierung war zu Beginn des Projektes lediglich,
dass sie von mobilen Endgeräte, also Smartphones, abrufbar sein sollte.
Dies lässt sich auf zwei Arten umsetzt:
\begin{itemize}
    \item Eine App entwickeln, welche auf dem Gerät installiert werden kann.
    \item Eine Webseite entwickeln, welche vom Gerät aufgerufen werden kann.
\end{itemize}
Die Entscheidung viel auf letztere Art, also eine Webseite.
Die Gründe dazu sind:
\begin{itemize}
    \item Das Projektteam hat diveres Erfahrunge
\end{itemize}


\subsection{\ac{MQTT} Datenverarbeitung}

Die Daten der Stromzähler werden per \ac{MQTT} an den Broker gesendet. \ref{state:mqtt}

\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{gfx/smic-arch-mqtt}
    \caption{
        Architektur des \ac{MQTT} Messagebroker und des Dataingress welcher die
        empfangenen Nachrichten in die Datenbank persistiert.
    }
    \label{fig:arch-mqtt}
\end{figure}

Der Dataingress (ebenfalls ein Python Poetry projekt) registriert sich dann auf die von
den Stromzählern gesendeten Events und arbeitet diese ab. Das Empfangen und Abarbeiten, bzw.
in die Datenbank schreiben wird von unterschiedlichen internen Komponenten übernommen.
Beim Abarbeiten wird zudem, falls ein Datensatz nicht prozessiert werden kann dies noch
einmal versucht. Beispielsweise kann die Datenbank noch nicht bereit sein.\footnote{
    Das kann beispielsweise passieren, wenn die Datenbank neu gestartet wird nach einem update.
}
Dadurch soll möglichst verhindert werden, dass eingehende Messdaten verloren gehen.

Auch der Dataingress verwendet die Datastore Python Library. Dies stellt sicher,
dass die \ac{API} und er Dataingress das gleiche Datenbankformat verwenden da
die Datenbank ja zwischen den beiden Applikationen geshart ist.

\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{gfx/dataingress-sequence}
    \caption{
        Das Sequenzdiagramm zeigt auf wie der Dataingress die \ac{MQTT} Messages
        von den Stromzählern abarbeitet und in die Datenbank persisitiert.
    }
    \label{fig:dataingress-sequence}
\end{figure}

Im Sequenzdiagramm des Dataingress (Abbildung \ref{fig:dataingress-sequence}) wird aufgezeigt
wie \ac{MQTT} Messages vom Dataingress abgearbeitet werden.
Die Messages müssen zuerst \ac{JSON} deserialisiert werden um in Python
gebraucht zuwerden. Danach werden die Messdaten und allenfalls der
Stromzähler mit Serialnummer in die Datenbank gespeichert.

\subsection{Automatisierte End to End tests}

Um sicherzustellen, dass das Projekt jederzeit funktioniert und keine Änderungen
aus Versehen andere Funktionalität beeinträchtigt, wurden Automatisierte
End to End tests erstellt. (Siehe Teststrategie \ref{teststrategie})

Diese Tests wurden Behaviour Driven implementiert.\footnote{
    Behavior-driven development (BDD) is an Agile software development methodology
    in which an application is documented and designed around the behavior a user
    expects to experience when interacting with it.
}\parencite{what_is_bdd} Die tests wurden anhand der Anforderungen \ref{aufgabenstellung}
und User Stories in der Gherking Sprache\footnote{https://cucumber.io/docs/gherkin/reference/} implementiert.

\section{Demo nach der ersten Phase}
Screenshot der ersten version
Rückmeldungen:
- grundsätzlich zufrieden
- Mobile nicht weiter zentral, Fokus auf Dashboard, Desktop

Neue Anforderungen:
Range/Zähler auswählen sowie typ der Daten
echte Daten automatisiert einspielen
THD und Power zusätzlich zu Spannung

\section{Demon nach der zweiten Phase}
- Labeling:
Labels graphisch darstellen
Labels mittels UI hinzufügen
