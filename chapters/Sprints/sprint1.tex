\section{Sprint 1}
Im ersten Sprint wurde der Grundstein für das Projekt sowie die Applikation gelegt.
Dies beinhaltete folgende Stories:
\begin{itemize}
   \item Teile des \ac{ATS} Codes sollen übernommen werden, so dass die Kommunikation mit Stromzählern möglich ist.
% in ADO gibt es no eine zweite story zur kommunikation, diese wird hier weggelassen
   \item Die Applikation DlmsQuickAccess soll an Benutzer soll so an Benutzer ausgeliefert werden, dass diese automatisch neue Updates erhalten.
   \item Die Applikation soll auf \ac{ADO} bei jedem neuem Commit automatisch gebaut und getestet werden. 
   \item Es soll eine Benutzerschnittstelle erstellt werden, welche alle Objekte eines Zählers auflistet.
% in ADO gibt es eine extra story zum ObjectModel parsen, diese wird hier weggelassen
\end{itemize}
In den folgenden Abschnitten werden die genannten Stories einzeln ausführlich beschrieben.
Als erstes wird jeweils das Ziel der Story genauer festgehalten.
Darauf folgen wird beschrieben wie die Story bearbeitet wurde, welche Schwierigkeiten aufgetreten sind und in welchem Zustand sich die Story zum Ende des Sprints befand.

\subsection{Implementation der Kommunikation mittels ATS Code}\label{s1:ats}
\dq Teile des \ac{ATS} Codes sollen übernommen werden, so dass die Kommunikation mit Stromzählern möglich ist.\dq

\subsubsection{Ziel}
Nebst des Codes für die Kommunikation mit Stromzähler beinhaltet das Projekt des \ac{ATS} viele weitere Komponenten wie beispielsweise eine Benutzerschnittstelle für das Verwalten von Testscripts oder einen Interpreter für die eigene Scriptsprache.
Die Story gilt als erledigt, wenn die eine erfolgreiche Kommunikation mit einem Stromzähler durchgeführt werden kann.
Dabei soll nur jener Code, welche effektiv für die Kommunikation zuständig ist, in die DlmsQuickAccess Solution eingebunden werden. 


\subsubsection{Vorgehen und Schwierigkeiten}

In Kapitel TODO wird erklärt, wieso der Code des \ac{ATS} als Kommunikationsstack ausgewählt wurde.
Die Story "Harvest parts of the ATS" beschäftigte sich damit, Teile des \ac{ATS} Codes so in die Anwendung einzubindend, dass Stromzählerdaten gelesen und geschrieben werden können.
Dabei trat die Schwierigkeit auf, dass alle Klassen des \ac{ATS} in einem einzelnen C\# Projekt mit dem Namen Befehlsinterpreter abgelegt sind.
Nebst den benötigten \ac{DLMS} Kommunikationskomponenten beinhaltet dieses Projekt auch Code für Benutzerschnittstellen sowie diversen andere Kommunikationsprotokolle.
Eine saubere Trennung der einzelnen Komponenten ist nicht erkennbar. 
Dies bestätigen auch die Code Metrics Results (TODO footnote was diese sind und wie sie erstellt werden können) sichtbar in Abbildung TODO.
Einzelne Klassen sind mit bis zu 71 anderen gekoppelt, während laut \parencite{quantitativeInvestigationRiskCodeMetrics} TODO neun eine gute Obergrenze wäre.
Abbildung TODO zeigt des weiteren, dass teils englische und teils deutsche Klassennamen verwendet werden.
Es ist somit nicht möglich, den \ac{ATS} Code als Bibliothek mittels eines NuGet TODO Paketes einzubinden.
Im Kapitel \ref{ausblick:ats_split} wird jedoch darauf hingewiesen, dass es in der Zukunft sinnvoll sein könnte,
das Befehlsinterpreter Projekt aufzuspalten und einzelne Komponenten als Bibliothek bereitzustellen.


Das Repository des \ac{ATS} wurde mittels Git Subtree TODO in das Projekt dieser Arbeit eingebunden. 
Dies ermöglichte es, dass Klassen und Funktionen, welche nicht benötigt werden, entfernt werden konnten.
Die Änderungen am \ac{ATS} Code mussten lediglich in das Repository dieser Arbeit gepusht werden.
Wäre anstelle von Git Subtree Git Submodule verwendet worden, wäre dies nicht möglich gewesen.
Neue Versionen des \ac{ATS} Code können ebenfalls gepullt und gemerget werden. 
Der Nachteil dieses Ansatzes ist es, dass es etwas schwieriger ist, die gemachten Änderungen zum Ursprungsrepository zu pushen \parencite{gitSubtree}.
Da die geplanten Änderungen jedoch nur vorsehen, Code zu löschen, ist dieser Nachteil nicht relevant.



\subsection{Deployment}
\dq Die Applikation DlmsQuickAccess soll an Benutzer soll so an Benutzer ausgeliefert werden, dass diese automatisch neue Updates erhalten.\dq

\subsubsection{Ziel}
Obwohl die Anwendung zu diesem Zeitpunkt noch über keinerlei Funktionen verfügt, welche für einen Benutzer nützlich sein könnten, soll das Deployment der Applikation bearbeitete werden.
Damit wird sichergestellt, dass WinUI3 Applikationen in der Umgebung der Landis+Gyr korrekt ausgeliefert werden können.
Dies ist wichtig, da es in der Vergangenheit Probleme mit restriktiven Sicherheitsrichtlinien gab.

Die Story gilt als abgeschlossen wenn es für einen Benutzer möglich ist die Applikation eigenständig zu installieren.
Updates, welche nach dem Installationszeitpunkt erscheinen, sollen automatisch aufgespielt werden.
\subsubsection{Vorgehen und Schwierigkeiten}



\subsection{Build bei Commit}
\dq Die Applikation soll auf \ac{ADO} bei jedem neuem Commit automatisch gebaut und getestet werden.\dq

\subsubsection{Ziel}
Die \ac{CI} Umgebung auf \ac{ADO} soll so konfiguriert werden, dass bei jeder neuen Änderung geprüft wird, ob diese valid ist und keine bestehenden Funktionen bricht.
Die Story gilt als erledigt, wenn bei jedem Commit automatisch ein vollständiger Build erstellt wird und alle UnitTests ausgeführt werden.

\subsubsection{Vorgehen und Schwierigkeiten}

\subsection{Darstellung des Object Model}
\dq Es soll eine Benutzerschnittstelle erstellt werden, welche alle Objekte eines Zählers auflistet.\dq

\subsubsection{Ziel}
Eine zentrale Funktion des zu ersetzenden \textit{Quick Access} ist die visuelle Auflistung aller Objekte eines Stromzählers.
In der neuen Applikation wird eine solche ebenfalls benötigt.
Die Story gilt als erledigt, wenn folgende Elemente der Objekte vollständig angezeigt werden:
\begin{itemize}
   \item Der Name des Objekts
   \item Die ClassId inklusive Version, Own Class Version und Sub Type
   \item Der Name und die Id aller Attribute und Methoden
\end{itemize}

\subsubsection{Vorgehen und Schwierigkeiten}

\pagebreak

\subsection{Build}
<RuntimeIdentifiers>win10-x86;win10-x64;win10-arm64</RuntimeIdentifiers> vs <RuntimeIdentifiers>win-x64</RuntimeIdentifiers>
Probleme beim Build via msbuild Kommando und im CI/CD

Probleme beim ausführen von tests via vstest.console.exe
"Could not find testhost"
Dieses Problem tritt ebenfalls auf, wenn ein neues Testprojekt erstllt wird und dies mit vstest abgespielt wird.

Lösung:
dotnet cli verwenden. neuses Problem:  The imported project "C:\\Program Files\\dotnet\\sdk\\6.0.200\\Microsoft\\DesktopBridge\\Microsoft.DesktopBridge.props" was not found.
Lösung:
neue Solution nur mit Test projekten

\subsection{CI/CD}

\subsection{Schwierigkeiten}
Die Azure DevOps Instanz der Landis+Gyr wird global verwaltet. Für neue Projekte, Anpassungen und Berechtigugen mussten jeweils die entsprechenden Prozesse eingehalten werden. (SP/Azure work item)
Projekt
Pipeline erstellen
Agent
Agent mit VS 2022

Workaround VS 2022 nicht gefunden
https://stackoverflow.com/questions/70174595/visual-studio-2022-not-listed-in-devops-build-solution-pipeline-task

Secure File für Zertifikat
-> Vorerst wurde der Private Key in das Repository eingecheckt, da keine Secure Files erstellt werden können. Verantwortlicher ist in den Ferien.


\subsection{InfraLib}
Parsen von ClassDescriptions kaum getestet. Xml node hat im Code einen anderen Namen als in den Dateien.

Neue tests für InfraLib schreiben und code fixen.

\subsection{Adapter Pattern}

Mithilfe des Adapter Pattern wurde die bestehende Klassenstrukture der InfraLib auf die benötigten Interfaces adaptiert.
Dies erlaubte es, die Interfaces genau so zu modellieren, wie sie für den DlmsQuickAccess benötigt werden.
Dependency auf InfraLib ist an einem Ort.


\subsection{Entscheidungen}

Mock Framework:
https://github.com/moq/moq4


Logging Framework
log4Net, weil es bereits für InfraLib verwendet wird. 

https://stackoverflow.com/questions/53092470/how-to-configure-logging-via-log4net-in-an-uwp-app

\subsection{Globaler Exception Handler}

Exceptions, welche vom Programm nicht abgefangen werden und zu einem Absturz der Anwendung führen, werden von einem globalen Exception Handler gefangen.
Dieser schreibt deren auftreten in die Log-Datei. Für vereinfachtes Troubeshooting, wir diese Log Datei auch sofort geöffnet. Das Programm stürtzt danach ab.

Limitierugen:
Exception, welche im Aufbau der Anwendung vorkommen. Also beispielsweise im XAML oder im Konstruktor eines ViewModels können nicht abgefangen werden.
https://docs.microsoft.com/en-us/windows/winui/api/microsoft.ui.xaml.application.unhandledexception?view=winui-3.0


\subsection{Versionen von .net}
WinUI3 benötigt spezifische Version net6.0-windows10.0.19041.0.
Test Projekt muss ebenfals diese als TargetFramwork haben.
Wenn dieses ausgewählt wird könne jedoch keine UT mehr ausgeführt werden.

UWP UnitTest Projekt hilft auch nicht

Lösung:
Eigenes Projekt für VM und so




UnitTest:

Internal Classes testen:
https://stackoverflow.com/questions/358196/c-sharp-internal-access-modifier-when-doing-unit-testing

\subsection{Dummy Klassen}
Für das Testig von Picasso Tool wurde Dummy CosemKlassen erstellt, welche diverse Edge-Cases abdekend.
Diese sind sehr praktisch für das entwickeln und testen der Anwendung.


\subsection{Sprint resultat}
Nur 2 stories fertig.


nichts fertig
Release funktioniert noch nicht
Unittest laufen noch nicht

Damit erster release n




